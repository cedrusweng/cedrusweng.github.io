<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第33条：使构造函数与new操作符无关 | 脚后跟着猫</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="当使用函数作为一个构造函数时，程序依赖于调用者是否记得使用new操作符来调用该构造函数。注意：该函数假设接收者是一个全新的对象。1234function User(name,pwd)&amp;#123;  this.name=name;  this.pwd=pwd;&amp;#125;
当调用者，忘记使用new关键字时，那么这个函数的接收者是全局对象。1234var u=User(&apos;wengxuesong&apos;,&apos;a">
<meta property="og:type" content="article">
<meta property="og:title" content="第33条：使构造函数与new操作符无关">
<meta property="og:url" content="http://cedrusweng.github.io/2016/06/13/第33条：使构造函数与new操作符无关/index.html">
<meta property="og:site_name" content="脚后跟着猫">
<meta property="og:description" content="当使用函数作为一个构造函数时，程序依赖于调用者是否记得使用new操作符来调用该构造函数。注意：该函数假设接收者是一个全新的对象。1234function User(name,pwd)&amp;#123;  this.name=name;  this.pwd=pwd;&amp;#125;
当调用者，忘记使用new关键字时，那么这个函数的接收者是全局对象。1234var u=User(&apos;wengxuesong&apos;,&apos;a">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/156514/201606/156514-20160614101956245-553595553.jpg">
<meta property="og:updated_time" content="2016-06-14T02:25:17.877Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第33条：使构造函数与new操作符无关">
<meta name="twitter:description" content="当使用函数作为一个构造函数时，程序依赖于调用者是否记得使用new操作符来调用该构造函数。注意：该函数假设接收者是一个全新的对象。1234function User(name,pwd)&amp;#123;  this.name=name;  this.pwd=pwd;&amp;#125;
当调用者，忘记使用new关键字时，那么这个函数的接收者是全局对象。1234var u=User(&apos;wengxuesong&apos;,&apos;a">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/156514/201606/156514-20160614101956245-553595553.jpg">
  
    <link rel="alternate" href="/atom.xml" title="脚后跟着猫" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">脚后跟着猫</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/scrollFrame">scrollFrame</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://cedrusweng.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-第33条：使构造函数与new操作符无关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/13/第33条：使构造函数与new操作符无关/" class="article-date">
  <time datetime="2016-06-13T07:34:34.052Z" itemprop="datePublished">2016-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      第33条：使构造函数与new操作符无关
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当使用函数作为一个构造函数时，程序依赖于调用者是否记得使用new操作符来调用该构造函数。注意：该函数假设接收者是一个全新的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,pwd</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.pwd=pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用者，忘记使用new关键字时，那么这个函数的接收者是全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u=User(<span class="string">'wengxuesong'</span>,<span class="string">'asdfasdfadf'</span>);</span><br><span class="line">u;<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">this</span>.name;<span class="comment">//'wengxuesong'</span></span><br><span class="line"><span class="keyword">this</span>.pwd;<span class="comment">//'asdfasdfadf'</span></span><br></pre></td></tr></table></figure></p>
<p>该函数返回了无意义的undefined，还会修改全局对象。<br>如果将User函数应用ES5的严格模式，那么它的接收者为undefined<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,pwd</span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.pwd=pwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> u=User(<span class="string">'wengxuesong'</span>,<span class="string">'asdfasdfadf'</span>);<span class="comment">//error:this is undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码会报错，因为在严格模式下直接运行的函数中的this是undefined，无法给undefined定义属性。<br>如何才能使User函数在不使用new操作符的情况下，还是按预期工作呢？提供一个不管怎样调用都工作如构造函数的函数。实现该函数的一个简单方法是检查函数的接收者是否是正确的User实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,pwd</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> User))&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> User(name,pwd); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.pwd=pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方式无论如何调用User函数，都会返回一个继承自User.prototype的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=User(<span class="string">'wengxuesong'</span>,<span class="string">'12123123'</span>);</span><br><span class="line"><span class="keyword">var</span> y=<span class="keyword">new</span> User(<span class="string">'songqiang'</span>,<span class="string">'sfasdfasdf'</span>);</span><br><span class="line">x <span class="keyword">instanceof</span> User;<span class="comment">//true</span></span><br><span class="line">y <span class="keyword">instanceof</span> User;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>这个模式的一个缺点是它需要额外的函数调用，因此代价有点高。而且，很难适用于可变参数函数，因为没有一种直接模拟apply方法将可变参数函数作为构造函数调用的方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,pwd</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self=<span class="keyword">this</span> <span class="keyword">instanceof</span> User?<span class="keyword">this</span>:<span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line">  self.name=name;</span><br><span class="line">  self.pwd=pwd;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Object.create需要一个原型对象作为参数，并返回一个继承自该原型对象的新对象。因此，当以函数的方式调用该版本的User函数时，结果将返回一个继承自User.prototype对象的新对象，并且该对象具有已经初始化的name和pwd属性。<br>Object.create只有在ES5环境中才是有效的，可以通过代码进行兼容。上节已经写过一次了，再写一遍加深印象吧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Object</span>.create === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">    <span class="built_in">Object</span>.create=<span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>)</span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">       F.prototype=prototype;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这里只实现了单参数的Object.create函数。真实版本的Object.create函数还接受一个可选的参数，该参数描述了一组定义在新对象上的属性描述符。<br>如果使用new操作符调用新版本的User参数会发生什么？<br>构造函数覆盖模式，使用new操作符调用该函数的行为就如以函数调用它的行为一样。这能工作完全利益于js允许new表达式的结果可以被构造函数中的显式return语句所覆盖。当User函数返回self对象时，new表达式的结果就变为self对象。该self对象可能是另一个绑定到this的对象。<br>防范误用构造函数可能并不是太值得去做，尤其是当仅仅是局部使用构造函数时。但是理解如果以错误的方式调用构造函数会造成严重后果很重要。至少文档化构造函数期望使用new操作符调用是很重要的，尤其是在跨大型代码库中其享构造函数或该构造函数来自一个共享库时。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关</li>
<li>当一个函数期望使用new操作符调用时，清晰地文档化该函数</li>
</ul>
<h2 id="附录一：Object-create方法"><a href="#附录一：Object-create方法" class="headerlink" title="附录一：Object.create方法"></a>附录一：Object.create方法</h2><p>以下内容来自Mozilla 开发者社区<br>Object.create()方法创建一个拥有指定原型和若干指定属性的对象。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Object.create(原型对象,[属性对象集])</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>如果原型对象不是null或一个对象值，则抛出一个TypeError异常</p>
<h3 id="实现类式继承"><a href="#实现类式继承" class="headerlink" title="实现类式继承"></a>实现类式继承</h3><h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.move=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x+=x;</span><br><span class="line">  <span class="keyword">this</span>.y+=y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>);<span class="comment">//构造函数借用</span></span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype=<span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect=<span class="keyword">new</span> Rectangle();</span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle;<span class="comment">//true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape;<span class="comment">//true</span></span><br><span class="line">rect.move(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//"Shape moved"</span></span><br></pre></td></tr></table></figure>
<p>画张图表示一下上面的关系<br><img src="http://images2015.cnblogs.com/blog/156514/201606/156514-20160614101956245-553595553.jpg" alt="继承关系" title="1465870265977.jpg"></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">  OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">MyClass.prototype=<span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">mixin(MyClass.prototype,OtherSuperClass.prototype);<span class="comment">//mixin</span></span><br><span class="line">MyClass.prototype.myMethod=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="propertyObject参数"><a href="#propertyObject参数" class="headerlink" title="propertyObject参数"></a>propertyObject参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o;</span><br><span class="line"><span class="comment">//创建原型为null的空对象</span></span><br><span class="line">o=<span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">o=&#123;&#125;;</span><br><span class="line"><span class="comment">//以字面量方式创建空对象相当于下面这句代码</span></span><br><span class="line">o=<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o=<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</span><br><span class="line">  <span class="comment">//创建对象的数据属性</span></span><br><span class="line">  foo:&#123;writable:<span class="literal">true</span>,configurable:<span class="literal">true</span>,value:<span class="string">'hello'</span>&#125;,</span><br><span class="line">  <span class="comment">//创建对象的访问器属性</span></span><br><span class="line">  bar:&#123;</span><br><span class="line">     configurable:<span class="literal">false</span>,</span><br><span class="line">     get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>;&#125;,</span><br><span class="line">     set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'setting "o.bar" to'</span>,val);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">o=<span class="keyword">new</span> Constructor();</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">o=<span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line"><span class="comment">//如果Constructor里有一些初始化代码，Object.create不能执行那些代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该相当于</span></span><br><span class="line">o=&#123;&#125;;</span><br><span class="line">o=<span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line">Constructor.call(o,args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个以另一个空对象为原型，且拥有一个属性p的对象</span></span><br><span class="line">o=<span class="built_in">Object</span>.create(&#123;&#125;,&#123;p:&#123;value:<span class="number">42</span>&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略了的属性默认为false，所以属性p是不可写，不可枚举，不可配置的</span></span><br><span class="line">o.p=<span class="number">24</span>;</span><br><span class="line">o.p;<span class="comment">//42</span></span><br><span class="line">o.q=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//'q'</span></span><br><span class="line"><span class="keyword">delete</span> o.p;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个可写的，可枚举的，可配置的属性p</span></span><br><span class="line">o2=<span class="built_in">Object</span>.create(&#123;&#125;,&#123;p:&#123;value:<span class="number">42</span>,writable:<span class="literal">true</span>,enumerable:<span class="literal">true</span>,configurable:<span class="literal">true</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="兼容版"><a href="#兼容版" class="headerlink" title="兼容版"></a>兼容版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>)&#123;</span><br><span class="line">  <span class="built_in">Object</span>.create=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">NOP</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">     <span class="keyword">var</span> hasOwn=<span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//1、如果o不是Object或null，抛出一个类型错误异常</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> o!==<span class="string">'object'</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object or null.'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2、使创建的一个新的对象为obj</span></span><br><span class="line">       <span class="comment">//3、设置obj的内部属性[[Prototype]]为o</span></span><br><span class="line">       NOP.prototype=o;</span><br><span class="line">       <span class="keyword">var</span> obj=<span class="keyword">new</span> NOP();</span><br><span class="line">       NOP.prototype=<span class="literal">null</span>;<span class="comment">//解除NOP函数的prototype的引用</span></span><br><span class="line">       <span class="comment">//4、如果参数有Properties，那么检测并添加属性到obj上。</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">var</span> Properties=<span class="built_in">Object</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> Properties)&#123;</span><br><span class="line">             <span class="keyword">if</span>(hasOwn.call(Properties,prop))&#123;</span><br><span class="line">                obj[prop]=Properties[prop];</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedrusweng.github.io/2016/06/13/第33条：使构造函数与new操作符无关/" data-id="cipetv51b0008toci22420smx" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编写高质量javascript代码的68条有效方法/">编写高质量javascript代码的68条有效方法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/06/13/第32条：始终不要修改__proto__属性/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">第32条：始终不要修改__proto__属性</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/编写高质量javascript代码的68条有效方法/">编写高质量javascript代码的68条有效方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/聊一聊HTML标签/">聊一聊HTML标签</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/编写高质量javascript代码的68条有效方法/" style="font-size: 20px;">编写高质量javascript代码的68条有效方法</a> <a href="/tags/聊一聊HTML标签/" style="font-size: 10px;">聊一聊HTML标签</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/13/第33条：使构造函数与new操作符无关/">第33条：使构造函数与new操作符无关</a>
          </li>
        
          <li>
            <a href="/2016/06/13/第32条：始终不要修改__proto__属性/">第32条：始终不要修改__proto__属性</a>
          </li>
        
          <li>
            <a href="/2016/06/13/第31条：使用Object.getPrototypeOf函数而不要使用__proto__属性/">第31条：使用Object.getPrototypeOf函数而不要使用__proto__属性</a>
          </li>
        
          <li>
            <a href="/2016/06/13/第30条：理解prototype、getPrototypeOf和__ptoto__之间的不同/">第30条：理解prototype、getPrototypeOf和__ptoto__之间的不同</a>
          </li>
        
          <li>
            <a href="/2016/05/31/html-commet/">聊一聊HTML &lt;!--...--&gt;标签</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 wengxuesong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/scrollFrame" class="mobile-nav-link">scrollFrame</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>